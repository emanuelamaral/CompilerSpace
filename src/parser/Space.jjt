/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
}

PARSER_BEGIN(Space)

package parser;
import recovery.*;

public class Space
{
  public static void main(String args []) throws ParseException
  {
    Space parser = new Space(System.in);
    while (true)
    {
      System.out.println("Lendo a entrada");
      System.out.println("Informe um programa:");
      try
      {

//        Space.inicio();
//        switch (Space.inicio())
//        {
//          case 0 : 
//          System.out.println("OK.");
//          break;
//          case 1 : 
//          System.out.println("Goodbye.");
//          break;
//          default : 
//          break;
//        }

		SimpleNode node = Space.inicio();
		node.dump(" -- > ");
      }
      catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        Space.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
  }


  static public String im(int x)
  {
    int k;
	String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try {
      s = s.substring(1,k);
    }
   catch (StringIndexOutOfBoundsException e)
	   {}
   return s;
  }
	
  static Token lastError = null;
  static boolean eof;    // vari\u00e1vel que indica se EOF foi alcan\u00e7ado
	
  // o m\u00e9todo abaixo consome tokens at\u00e9 alcan\u00e7ar um que perten\u00e7a ao conjunto
  // de sincroniza\u00e7\u00e3o
  static void consumeUntil(RecoverySet g,
	                 ParseException e,
	                 String met) throws ParseEOFException,
	                                    ParseException
  {
	Token tok;
	System.out.println();
	System.out.println("*** " + met + " ***");
	System.out.println("     Conjunto de sincroniza\u00e7\u00e3o: " + g);
		
	if (g == null) throw e; // se o conjunto \u00e9 null, propaga a exce\u00e7\u00e3o
	
	tok = getToken(1); // pega token corrente
	while ( ! eof )	{ // se n\u00e3o chegou ao fim do arquivo
	  if ( g.contains(tok.kind)) {//achou um token no conjunto
	    System.out.println("     Encontrado token de sincroniza\u00e7\u00e3o: " + 
	                       im(tok.kind));
	    break;
	  }
	  System.out.println("     Ignorando o token: " + im(tok.kind));
	  getNextToken();     // pega pr\u00f3ximo token       
      tok = getToken(1);
	  if (tok.kind == EOF && ! g.contains(EOF) ) // fim da entrada?   
	      eof = true;
	}
    if ( tok != lastError)  {
	  System.out.println(e.getMessage());
	  lastError = tok;
	   
	}
	if ( eof )
	  throw new ParseEOFException("Encontrei EOF onde n\u00e3o deveria.");
  }
  
}

PARSER_END(Space)

SKIP :
{
  " "
| "\r"
| "\t"
}

TOKEN : /* OPERADORES ARITMETICOS*/
{
  < MAIS 			: "+" >
| < MENOS 			: "-" >
| < VEZES 			: "*" >
| < DIVIDE 			: "/" >
}

TOKEN : /* OPERADORES RELACIONAIS*/
{
  < MAIOR 			: " >"	>
| < MENOR 			: "< "	>
| < MAIOR_IGUAL 	: " >=" >
| < MENOR_IGUAL 	: "< =" >
| < IGUAL_IGUAL 	: "=="	>
| < DIFERENTE		: "!="	>
}

TOKEN : /* OPERADORES DE ATRIBUICAO*/
{
  < IGUAL		:	"="	 >
| < MAIS_IGUAL	:	"+=" >
| < MENOS_IGUAL :   "-=" >
| < IN			:	"in" >
}

TOKEN : /* OPERADORES LOGICOS*/
{
  	< AND		: "and"		>
|   < OR 		: "or"		>
|   < NOT 		: "not"		>
}

TOKEN : /* OPERADORES DE DELIMITACAO*/
{
  
  < INICIO_FIM_BLOCO	 	: ":"	>
| < VIRGULA					: "," 	>
| < PONTO_VIRGULA			: ";" 	>
| < INICIA_VARIAVEL 		: "__"	>
| < ABRE_PARENTESES			: "("	>
| < FECHA_PARENTESES		: ")"	>
| < PULA_LINHA				: "\n"  >
| < DELIMITA_ESTRELA		: "'"	>
}

TOKEN : /* PALAVRAS RESERVADAS*/
{
  < BIG_BANG		:	"big_bang"		>
| < TIPO_LUA		:	"lua" 			>
| < TIPO_QUASAR  	:	"quasar" 		>
| < TIPO_ESTRELA 	:	"estrela"		>
| < BURACO_BRANCO	:	"buraco_branco" >
| < BURACO_NEGRO	:	"buraco_negro"	>
| < ORBITA			:	"orbita"		>
| < TRANSLACAO		:	"translacao"	>
| < ANA_BRANCA		:	"ana_branca"	>
| < ANA_MARROM 		:	"ana_marrom"	>
| < ESPACO			:	"espaco"		>
| < LAMBDA			:	"lambda"		>
| < TIPO_VACUO		:	"vacuo"			>
| < GALAXIA			:	"galaxia"		>
| < SUPER_NOVA		:	"$"				>
| < RETORNO			:	"retorno"		>
}

TOKEN : /* IDENTIFICADOR */
{
  < ID 	:	 < LETRA >(< LETRA> | < DIGITO>)* >
}

TOKEN :  /* TERMINAIS COMPLEXOS */
{
  < NUMERO 	: (< DIGITO >)+ 		>
| < DIGITO 	: [ "0"-"9" ] 			>
| < LETRA	: ["A"-"Z"] | ["a"-"z"] >
}

/* NÃƒO TERMINAIS */

SimpleNode inicio() :
{}
{
   (tipoRetorno() galaxia() identificador() abreParenteses() fechaParenteses() inicioFimBloco() pulaLinha() (bloco())* retorno() valorPrimitivo() inicioFimBloco() pulaLinha()
|	lambda() inicioFimBloco() pulaLinha() (constantes())* inicioFimBloco() pulaLinha())*
	bigBang() inicioFimBloco() pulaLinha() (bloco())* inicioFimBloco() pulaLinha()
{ return jjtThis; } 
}

void tipoRetorno():
{RecoverySet tipoRetornoSinc = First.tipoRetorno;}
{
  try { 
  	tipoVacuo() | tipoQuasar() | tipoLua() | tipoEstrela()
	}catch(ParseException e) {
		consumeUntil(tipoRetornoSinc, e, "Erro em - > tipoRetorno()");
	}
}

void constantes():
{}
{
	declaracaoDeVariaveis() igual() (numero() | gerarEstrela() ) pulaLinha()
}

void bloco() :
{}
{
	(declaracaoDeVariaveis()  | comandos())* pulaLinha()
    				
}

void declaracaoDeVariaveis() :
{RecoverySet declaracaoVarSinc = First.declaracaoDeVariavel;}
{
	try { 
		iniciaVariavel() tipoDeVariavel() identificador() (modoDaVariavel())*
	}catch(ParseException e) {
		consumeUntil(declaracaoVarSinc, e, "Erro em - > declaracaoDeVariaveis()");
	}
}

void comandos() :
{}
{
  (atribuicao())
| (anaBranca() abreParenteses() condicao() decideFinal())(inicioFimBloco() (bloco())* decideAnaMarrom())
| (orbita() abreParenteses() identificador() in() espaco() configuraEspaco()fechaParenteses())(inicioFimBloco() (bloco())* inicioFimBloco())
| (translacao() abreParenteses() condicao()decideFinal())(inicioFimBloco() (bloco())* inicioFimBloco())
| (buracoNegro()abreParenteses()iniciaVariavel()tipoDeVariavel()virgula()expressao()fechaParenteses())
| (buracoBranco()abreParenteses()expressao()fechaParenteses())
}
void atribuicao():
{}
{
  identificador() tipoAtribuicao() (valorPrimitivo()(modoDeAtribuicao())*)
}

void tipoAtribuicao():
{}
{
  igual() | maisIgual() | menosIgual()
}

void modoDeAtribuicao():
{}
{
  operacaoAritmetica() valorPrimitivo()
}

void valorPrimitivo():
{}
{
  numero() | gerarEstrela() | identificador()
}

void operacaoAritmetica():
{}
{
 ( mais() | menos() | vezes() | divide() | abreParenteses() | fechaParenteses() )
}

void decideAnaMarrom():
{}
{
  inicioFimBloco() (pulaLinha()bloco() | anaMarrom() inicioFimBloco()(bloco())* inicioFimBloco())
}

void condicao():
{}
{
  expressao()(maior() | menor() | maiorIgual() | menorIgual() | in())+expressao()
}

void expressao() :
{}
{
  identificador() | numero() | gerarEstrela()
}

void decideFinal() :
{}
{
  (and() condicao()| or() condicao())*fechaParenteses()
}

void configuraEspaco():
{}
{
	abreParenteses()numero()virgula()numero()fechaParenteses()  
}

void gerarEstrela():
{}
{
  delimitaEstrela()(numero() | identificador())*delimitaEstrela()
}

void tipoDeVariavel() :
{}
{
  tipoQuasar() | tipoEstrela() | tipoLua()
}

void valorAtribuicao() :
{}
{
  numero() | letra() | luaCheia() | luaNova() | identificador() 
}

void modoDaVariavel() :
{}
{
  virgula() identificador()
}

/* TERMINAIS */

void tipoVacuo():
{}
{
  < TIPO_VACUO>
}

void tipoQuasar():
{}
{
  < TIPO_QUASAR>
}

void tipoLua():
{}
{
  < TIPO_LUA>
}

void tipoEstrela():
{}
{
  < TIPO_ESTRELA>
}

void galaxia():
{RecoverySet galaxiaSinc = First.galaxia;}
{
	try { 
  		< GALAXIA>
  	}catch(ParseException e) {
		consumeUntil(galaxiaSinc, e, "Erro em - > galaxia()");
  	}
}

void identificador():
{RecoverySet identificadorSinc = First.identificador;}
{
  	try { 
  		< ID>
	}catch(ParseException e) {
		consumeUntil(identificadorSinc, e, "Erro em - > identificador()");
	}
}

void abreParenteses():
{RecoverySet abreParenSinc = First.abreParenteses;}
{
  	try { 
  		< ABRE_PARENTESES>
	}catch(ParseException e) {
		consumeUntil(abreParenSinc, e, "Erro em - > abreParenteses()");
	}	
}

void fechaParenteses():
{RecoverySet fechaParenSinc = First.fechaParenteses;}
{
  	try { 
  		< FECHA_PARENTESES>
	}catch(ParseException e) {
		consumeUntil(fechaParenSinc, e, "Erro em - > fechaParenteses()");
	}
}

void inicioFimBloco():
{RecoverySet incioFimBlocoSinc = First.inicioFimBloco;}
{
	try {
		< INICIO_FIM_BLOCO>
	}catch(ParseException e) {
		consumeUntil(incioFimBlocoSinc, e, "Erro em - > inicioFimBloco()");
	}
}

void pulaLinha():
{RecoverySet pulaLinhaSinc = First.pulaLinha;}
{
	try { 
		< PULA_LINHA>
	}catch(ParseException e) {
		consumeUntil(pulaLinhaSinc, e, "Erro em - > pulaLinha()");
	}
}

void retorno():
{RecoverySet retornoSinc = First.retorno;}
{
  	try { 
  		< RETORNO>
	}catch(ParseException e) {
		consumeUntil(retornoSinc, e, "Erro em - > retorno()");
	}
}

void lambda():
{}
{
  < LAMBDA>
}

void bigBang():
{}
{
  < BIG_BANG>
}

void igual():
{}
{
  < IGUAL>
}

void numero():
{}
{
  < NUMERO>
}

void iniciaVariavel():
{}
{
  < INICIA_VARIAVEL>
}

void anaBranca():
{}
{
  < ANA_BRANCA>
}

void orbita():
{}
{
  < ORBITA>
}


void in():
{}
{
  < IN>
}

void espaco():
{}
{
  < ESPACO>
}


void translacao():
{}
{
  < TRANSLACAO>
}

void buracoNegro():
{}
{
  < BURACO_NEGRO>
}

void virgula():
{}
{
  < VIRGULA>
}

void buracoBranco():
{}
{
  < BURACO_BRANCO>
}

void maisIgual():
{}
{
  < MAIS_IGUAL>
}

void menosIgual():
{}
{
  < MENOS_IGUAL>
}

void menos():
{}
{
  < MENOS>
}

void mais():
{}
{
  < MAIS>
}

void vezes():
{}
{
  	< VEZES>
}

void divide():
{}
{
  < DIVIDE>
}

void maior():
{}
{
  < MAIOR>
}

void menor():
{}
{
  < MENOR>
}

void maiorIgual():
{}
{
  < MAIOR_IGUAL>
}

void menorIgual():
{}
{
  < MENOR_IGUAL>
}

void and():
{}
{
  < AND>
}

void or():
{}
{
  < OR>
}

void not():
{}
{
  < NOT>
}

void delimitaEstrela():
{}
{
  < DELIMITA_ESTRELA>
}

void anaMarrom():
{}
{
  < ANA_MARROM>
}

void letra():
{}
{
  < LETRA>
}

void luaCheia():
{}
{
  "lua_cheia"
}

void luaNova():
{}
{
  "lua_nova"
}

